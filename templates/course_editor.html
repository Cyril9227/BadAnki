{% extends "layout.html" %}

{% block title %}Course Editor{% endblock %}

{% block head %}
{{ super() }}
<style>
    .item-name {
        cursor: pointer;
    }
    .item-actions {
        display: none;
    }
    .list-group-item:hover .item-actions {
        display: inline-block;
    }
    .item-actions .btn {
        padding: 0.1rem 0.4rem;
        font-size: 0.8rem;
    }
    .api-status {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-left: 5px;
    }
    .api-key-good {
        background-color: green;
    }
    .api-key-bad {
        background-color: red;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <!-- File Tree Column -->
        <div class="col-lg-4">
            <div class="align-items-center mb-2">
                <h4>Courses</h4>
                <button class="btn btn-sm btn-outline-success new-folder-btn d-none d-lg-inline-block" data-path="">
                    <i class="fas fa-plus"></i> New Folder
                </button>
            </div>
            <div id="file-tree">
                <!-- File tree will be loaded here by JavaScript -->
            </div>
            <button class="btn btn-sm btn-outline-success new-folder-btn d-lg-none mt-2" data-path="">
                <i class="fas fa-plus"></i> New Folder
            </button>
        </div>

        <!-- Editor Column -->
        <div class="col-lg-8">
            <div id="editor-container" style="display: none;">
                <h4 id="editing-filename"></h4>
                <form id="editor-form">
                    <input type="hidden" id="current-file-path" name="path">
                    <div class="form-group mb-2">
                        <textarea id="markdown-editor" name="content" class="form-control" rows="15"></textarea>
                    </div>
                    <div class="d-flex flex-wrap gap-2 d-grid d-md-flex">
                        <button type="submit" class="btn btn-primary">Save</button>
                        <div class="btn-group">
                            <button type="button" id="generate-cards-btn" class="btn {{ 'btn-success' if gemini_api_key_exists or anthropic_api_key_exists else 'btn-secondary' }} dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false" {% if not gemini_api_key_exists and not anthropic_api_key_exists %}disabled{% endif %}>
                                Generate Cards
                            </button>
                            <ul class="dropdown-menu">
                                {% if gemini_api_key_exists %}
                                    <li><a class="dropdown-item" href="#" id="generate-cards-gemini-btn">Using Gemini</a></li>
                                {% endif %}
                                {% if anthropic_api_key_exists %}
                                    <li><a class="dropdown-item" href="#" id="generate-cards-anthropic-btn">Using Anthropic</a></li>
                                {% endif %}
                                <li><hr class="dropdown-divider"></li>
                                <li class="d-none d-lg-block"><a class="dropdown-item" href="#" id="generate-cards-ollama-btn">Using Ollama</a></li>
                            </ul>
                        </div>
                        <button type="button" id="download-btn" class="btn btn-info">Download File</button>
                    </div>
                </form>
                <hr>
                <h5>Live Preview</h5>
                <div id="live-preview" class="border p-3"></div>
                <div id="drop-zone-editor" class="border rounded p-3 mt-3 text-center text-muted" style="border-style: dashed !important;">
                    Drag & Drop .md files here or click to upload
                </div>
            </div>
            <div id="no-file-selected" class="text-center text-muted pt-5">
                <p>Select a file to start editing or create a new one.</p>
                <div id="drop-zone-main" class="border rounded p-5 mt-3 text-center text-muted" style="border-style: dashed !important;">
                    Drag & Drop .md files here or click to upload
                </div>
            </div>
        </div>
    </div>
</div>

{% include 'partials/card_generation_modal.html' %}
<input type="file" id="file-input" multiple accept=".md" style="display: none;">
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    const fileTreeContainer = document.getElementById('file-tree');
    const editorContainer = document.getElementById('editor-container');
    const noFileSelected = document.getElementById('no-file-selected');
    const markdownEditor = document.getElementById('markdown-editor');
    const livePreview = document.getElementById('live-preview');
    const editorForm = document.getElementById('editor-form');
    const editingFilename = document.getElementById('editing-filename');
    const currentFilePathInput = document.getElementById('current-file-path');
    const downloadBtn = document.getElementById('download-btn');
    const saveBtn = document.querySelector('button[type="submit"]'); // Re-target the save button
    const dropZoneMain = document.getElementById('drop-zone-main');
    const dropZoneEditor = document.getElementById('drop-zone-editor');
    const fileInput = document.getElementById('file-input');

    let currentDirectory = ''; // Tracks the currently selected directory

    function loadFileTree() {
        fetch('/api/courses-tree')
            .then(response => response.json())
            .then(data => {
                fileTreeContainer.innerHTML = buildTreeHTML(data);
            });
    }

    function buildTreeHTML(nodes) {
        let html = '<div class="list-group list-group-flush">';
        nodes.forEach((node, index) => {
            const padding = (node.depth || 0) * 20;
            const safePath = node.path.replace(/[^a-zA-Z0-9]/g, '-');
            const collapseId = `collapse-${safePath}-${index}`;

            if (node.type === 'directory') {
                html += `
                    <div style="padding-left: ${padding}px;">
                        <div class="list-group-item d-flex justify-content-between align-items-center" data-bs-toggle="collapse" href="#${collapseId}" role="button" aria-expanded="false" aria-controls="${collapseId}">
                            <span class="item-name folder-item" data-path="${node.path}">
                                <i class="fas fa-folder"></i> ${node.name}
                            </span>
                            <span class="item-actions">
                                <button class="btn btn-outline-success new-file-btn" data-path="${node.path}" title="New File"><i class="fas fa-plus"></i></button>
                                <button class="btn btn-outline-danger delete-item-btn" data-path="${node.path}" data-type="folder" title="Delete Folder"><i class="fas fa-trash-alt"></i></button>
                            </span>
                        </div>
                        <div class="collapse" id="${collapseId}">
                           ${node.children && node.children.length > 0 ? buildTreeHTML(node.children) : ''}
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div style="padding-left: ${padding}px;">
                        <div class="list-group-item d-flex justify-content-between align-items-center">
                            <span class="item-name file-item" data-path="${node.path}">
                                <i class="fas fa-file-alt"></i> ${node.title || node.name}
                            </span>
                            <span class="item-actions">
                                <button class="btn btn-outline-danger delete-item-btn" data-path="${node.path}" data-type="file" title="Delete File"><i class="fas fa-trash-alt"></i></button>
                            </span>
                        </div>
                    </div>
                `;
            }
        });
        html += '</div>';
        return html;
    }

    async function createNewItem(type, parentPath) {
        const { value: name } = await Swal.fire({
            title: `Enter the name for the new ${type}:`,
            input: 'text',
            inputLabel: `${type.charAt(0).toUpperCase() + type.slice(1)} Name`,
            showCancelButton: true,
            inputValidator: (value) => {
                if (!value) {
                    return 'You need to write something!'
                }
            }
        });

        if (!name) return;

        const newPath = parentPath ? `${parentPath}/${name}` : name;
        const finalPath = type === 'file' && !newPath.endsWith('.md') ? `${newPath}.md` : newPath;

        fetch(`/api/course-item`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: finalPath, type: type })
        })
        .then(handleResponse)
        .then(() => {
            loadFileTree();
            if (type === 'file') {
                loadEditorContent(finalPath);
            }
        })
        .catch(handleError);
    }

    async function deleteItem(path, type) {
        const result = await Swal.fire({
            title: `Are you sure you want to delete this ${type}?`,
            text: `Path: ${path}. This action cannot be undone.`,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Yes, delete it!'
        });

        if (!result.isConfirmed) {
            return;
        }

        fetch(`/api/course-item`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: path, type: type })
        })
        .then(handleResponse)
        .then(() => {
            loadFileTree();
            if (currentFilePathInput.value === path) {
                editorContainer.style.display = 'none';
                noFileSelected.style.display = 'block';
                currentFilePathInput.value = '';
                markdownEditor.value = '';
                currentDirectory = ''; // Reset directory context
            }
        })
        .catch(handleError);
    }

    function loadEditorContent(path) {
        fetch(`/api/course-content/${path}`)
            .then(handleResponse)
            .then(content => {
                currentDirectory = path.substring(0, path.lastIndexOf('/'));
                editorContainer.style.display = 'block';
                noFileSelected.style.display = 'none';
                editingFilename.textContent = `Editing: ${path}`;
                currentFilePathInput.value = path;
                markdownEditor.value = content;
                updatePreview();

                if (window.innerWidth < 992) { // 992px is the breakpoint for lg devices
                    editorContainer.scrollIntoView({ behavior: 'smooth' });
                }
            })
            .catch(handleError);
    }

    document.body.addEventListener('click', function(e) {
        const buttonTarget = e.target.closest('.item-actions button');
        const newFolderRootBtn = e.target.closest('.new-folder-btn:not(.item-actions button)');

        if (buttonTarget || newFolderRootBtn) {
            e.stopPropagation(); // Prevent the collapse toggle when a button is clicked
            const btn = buttonTarget || newFolderRootBtn;
            const path = btn.dataset.path;

            if (btn.classList.contains('new-file-btn')) {
                createNewItem('file', path);
            } else if (btn.classList.contains('new-folder-btn')) {
                createNewItem('folder', ''); // Root folder creation
            } else if (btn.classList.contains('delete-item-btn')) {
                const type = btn.dataset.type;
                deleteItem(path, type);
            }
            return;
        }

        const fileTarget = e.target.closest('.file-item');
        if (fileTarget) {
            const path = fileTarget.dataset.path;
            loadEditorContent(path);
            document.querySelectorAll('.list-group-item').forEach(item => item.classList.remove('bg-light'));
            fileTarget.closest('.list-group-item').classList.add('bg-light');
            return;
        }

        const folderTarget = e.target.closest('.folder-item');
        if (folderTarget) {
            const path = folderTarget.dataset.path;
            currentDirectory = path;
            document.querySelectorAll('.list-group-item').forEach(item => item.classList.remove('bg-light'));
            folderTarget.closest('.list-group-item').classList.add('bg-light');
            
            editorContainer.style.display = 'none';
            noFileSelected.style.display = 'block';
            currentFilePathInput.value = '';
            markdownEditor.value = '';
        }
    });

    editorForm.addEventListener('submit', function (e) {
        e.preventDefault();
        const path = currentFilePathInput.value;
        const content = markdownEditor.value;

        fetch(`/api/course-content`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: path, content: content })
        })
        .then(handleResponse)
        .then(() => {
            Swal.fire({
                toast: true,
                position: 'top-end',
                icon: 'success',
                title: 'File saved successfully!',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
            loadFileTree();
        })
        .catch(handleError);
    });

    downloadBtn.addEventListener('click', function() {
        const path = currentFilePathInput.value;
        if (path) {
            window.location.href = `/api/download-course/${path}`;
        } else {
            Swal.fire({
                toast: true,
                position: 'top-end',
                icon: 'error',
                title: 'Please select a file to download.',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
        }
    });

    function setupDropZone(dropZone) {
        if (!dropZone) return;
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-primary');
            dropZone.classList.remove('text-muted');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-primary');
            dropZone.classList.add('text-muted');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-primary');
            dropZone.classList.add('text-muted');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files, currentDirectory);
            }
        });
    }

    fileInput.addEventListener('change', (e) => {
        const files = e.target.files;
        if (files.length > 0) {
            handleFileUpload(files, currentDirectory);
        }
    });

    function handleFileUpload(files, uploadDirectory) {
        const mdFiles = Array.from(files).filter(file => file.name.endsWith('.md'));
        if (mdFiles.length === 0) {
            Swal.fire({
                toast: true,
                position: 'top-end',
                icon: 'error',
                title: 'No Markdown (.md) files found.',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
            return;
        }

        let uploadedCount = 0;
        mdFiles.forEach(file => {
            const reader = new FileReader();
            reader.onload = function(event) {
                const content = event.target.result;
                const path = uploadDirectory ? `${uploadDirectory}/${file.name}` : file.name;

                fetch(`/api/course-content`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path, content: content })
                })
                .then(handleResponse)
                .then(() => {
                    uploadedCount++;
                    if (uploadedCount === mdFiles.length) {
                        Swal.fire({
                            toast: true,
                            position: 'top-end',
                            icon: 'success',
                            title: `Successfully uploaded ${uploadedCount} file(s)!`,
                            showConfirmButton: false,
                            timer: 3000,
                            timerProgressBar: true
                        });
                        loadFileTree();
                    }
                })
                .catch(handleError);
            };
            reader.readAsText(file);
        });
    }

    setupDropZone(dropZoneMain);
    setupDropZone(dropZoneEditor);

    function generateCards(apiUrl) {
        const content = markdownEditor.value;
        if (!content.trim()) {
            Swal.fire({
                toast: true,
                position: 'top-end',
                icon: 'warning',
                title: 'Editor is empty. Please add content.',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
            return;
        }

        cardsModalBody.innerHTML = '';
        loadingSpinner.style.display = 'block';
        saveCardsBtn.disabled = true;
        cardsModal.show();

        // Start showing random messages
        let messageIndex = 0;
        loadingMessage.textContent = loadingMessages[messageIndex];
        messageInterval = setInterval(() => {
            messageIndex = (messageIndex + 1) % loadingMessages.length;
            loadingMessage.textContent = loadingMessages[messageIndex];
        }, 2500);


        fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: content })
        })
        .then(handleResponse)
        .then(data => {
            clearInterval(messageInterval);
            loadingSpinner.style.display = 'none';
            generatedCardsData = data.cards || [];
            if (generatedCardsData.length > 0) {
                displayGeneratedCards(generatedCardsData);
                saveCardsBtn.disabled = false;
            } else {
                cardsModalBody.innerHTML = '<p>No cards were generated. Try refining your course content.</p>';
            }
        })
        .catch(error => {
            clearInterval(messageInterval);
            loadingSpinner.style.display = 'none';
            cardsModalBody.innerHTML = `<p class="text-danger">Error: ${error.message}</p>`;
            console.error('Error generating cards:', error);
        });
    }

    document.addEventListener('click', function(e) {
        if (e.target.matches('#generate-cards-gemini-btn')) {
            e.preventDefault();
            generateCards('/api/generate-cards');
        }
        if (e.target.matches('#generate-cards-anthropic-btn')) {
            e.preventDefault();
            generateCards('/api/generate-cards-anthropic');
        }
        if (e.target.matches('#generate-cards-ollama-btn')) {
            e.preventDefault();
            generateCards('/api/generate-cards-ollama');
        }
    });

    function displayGeneratedCards(cards) {
        let html = '<div id="generated-cards-container">';
        cards.forEach((card, index) => {
            const questionHTML = marked.parseInline(card.question || '');
            const answerHTML = marked.parseInline(card.answer || '');
            html += `
                <div class="card mb-3" data-card-index="${index}">
                    <div class="card-header d-flex flex-column flex-sm-row justify-content-sm-between align-items-start align-items-sm-center">
                        <div class="form-check">
                            <input class="form-check-input approve-checkbox" type="checkbox" id="approve-${index}" checked>
                            <label class="form-check-label" for="approve-${index}">
                                <strong>Card ${index + 1}</strong>
                            </label>
                        </div>
                        <div class="mt-2 mt-sm-0">
                            <button class="btn btn-sm btn-outline-primary edit-card-btn">Edit</button>
                            <button class="btn btn-sm btn-outline-danger delete-card-btn">Delete</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="card-content">
                            <p><strong>Q:</strong> <span class="card-question">${questionHTML}</span></p>
                            <p><strong>A:</strong> <span class="card-answer">${answerHTML}</span></p>
                        </div>
                        <div class="edit-form" style="display: none;">
                            <div class="mb-2">
                                <label class="form-label">Question:</label>
                                <textarea class="form-control edit-question">${card.question}</textarea>
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Answer:</label>
                                <textarea class="form-control edit-answer">${card.answer}</textarea>
                            </div>
                            <button class="btn btn-sm btn-success save-edit-btn">Save</button>
                            <button class="btn btn-sm btn-secondary cancel-edit-btn">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        cardsModalBody.innerHTML = html;
        if (window.MathJax) {
            MathJax.typesetPromise([cardsModalBody]);
        }
    }

    cardsModalBody.addEventListener('click', function(e) {
        const target = e.target;
        const cardElement = target.closest('.card');
        if (!cardElement) return;

        const index = parseInt(cardElement.dataset.cardIndex, 10);

        if (target.classList.contains('delete-card-btn')) {
            generatedCardsData[index] = null;
            cardElement.remove();
        } else if (target.classList.contains('edit-card-btn')) {
            const cardData = generatedCardsData[index];
            cardElement.querySelector('.edit-question').value = cardData.question;
            cardElement.querySelector('.edit-answer').value = cardData.answer;
            cardElement.querySelector('.card-content').style.display = 'none';
            cardElement.querySelector('.edit-form').style.display = 'block';
        } else if (target.classList.contains('cancel-edit-btn')) {
            cardElement.querySelector('.card-content').style.display = 'block';
            cardElement.querySelector('.edit-form').style.display = 'none';
        } else if (target.classList.contains('save-edit-btn')) {
            const questionTextarea = cardElement.querySelector('.edit-question');
            const answerTextarea = cardElement.querySelector('.edit-answer');
            const newQuestion = questionTextarea.value;
            const newAnswer = answerTextarea.value;

            generatedCardsData[index].question = newQuestion;
            generatedCardsData[index].answer = newAnswer;

            const questionSpan = cardElement.querySelector('.card-question');
            const answerSpan = cardElement.querySelector('.card-answer');
            questionSpan.innerHTML = marked.parseInline(newQuestion);
            answerSpan.innerHTML = marked.parseInline(newAnswer);

            if (window.MathJax) {
                MathJax.typesetPromise([questionSpan, answerSpan]);
            }

            cardElement.querySelector('.card-content').style.display = 'block';
            cardElement.querySelector('.edit-form').style.display = 'none';
        }
    });

    saveCardsBtn.addEventListener('click', function() {
        const approvedCards = [];
        const cardElements = cardsModalBody.querySelectorAll('.card');

        cardElements.forEach(cardElement => {
            const index = parseInt(cardElement.dataset.cardIndex, 10);
            const isApproved = cardElement.querySelector('.approve-checkbox').checked;

            if (isApproved && generatedCardsData[index]) {
                approvedCards.push(generatedCardsData[index]);
            }
        });

        if (approvedCards.length === 0) {
            Swal.fire({
                toast: true,
                position: 'top-end',
                icon: 'warning',
                title: 'No approved cards to save.',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
            return;
        }

        fetch('/api/save-cards', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cards: approvedCards })
        })
        .then(handleResponse)
        .then(data => {
            Swal.fire({
                icon: 'success',
                title: 'Success!',
                text: data.message,
            });
            cardsModal.hide();
        })
        .catch(handleError);
    });

    function handleResponse(response) {
        if (!response.ok) {
            return response.json().then(err => { throw new Error(err.detail || `HTTP error! status: ${response.status}`) });
        }
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.indexOf("application/json") !== -1) {
            return response.json();
        }
        return {}; 
    }

    function handleError(error) {
        Swal.fire({
            toast: true,
            position: 'top-end',
            icon: 'error',
            title: `An error occurred: ${error.message}`,
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true
        });
        console.error(error);
    }

    markdownEditor.addEventListener('input', updatePreview);
    function updatePreview() {
        livePreview.innerHTML = marked.parse(markdownEditor.value);
        MathJax.typesetPromise([livePreview]);
    }

    loadFileTree();
    const initialPath = "{{ course_path|default('') }}";
    if (initialPath && initialPath !== 'home') {
        loadEditorContent(initialPath);
    }
});
</script>
{% endblock %}
