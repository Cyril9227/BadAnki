# Gemini Agent Session Documentation

This document provides a comprehensive overview of the Anki Clone project, its structure, and the development session history. It is intended to be a reference for future Gemini agents and developers.

## 1. Project Overview

This project is a web-based, simplified clone of the Anki flashcard application. It uses a spaced repetition system (inspired by SM-2) to help users study and remember information efficiently. The application is built with Python using the FastAPI framework for the backend and Jinja2 templates for the frontend. It also includes a Telegram bot for user interaction.

## 2. Core Technologies

- **Backend:** Python 3.10+ with FastAPI
- **Frontend:** Jinja2 Templates with Bootstrap 5 CSS
- **Database:** PostgreSQL (production), SQLite (local)
- **Telegram Bot:** `python-telegram-bot` library
- **Markdown Parsing:** `frontmatter` library for course content.
- **LLM Integration:** `google-generativeai` for card generation, `ollama` for local card generation.
- **Deployment:** Render.com (Free Tier)

## 3. Project Structure

The project is organized into a main FastAPI application (`main.py`), a Telegram bot (`bot.py`), database scripts, and Jinja2 templates. Course content, previously stored in local Markdown files, is now managed in a PostgreSQL database to support a stateless deployment environment.

```
/
├── main.py             # The main FastAPI application file.
├── bot.py              # Contains the logic for the Telegram bot.
├── crud.py             # Contains database create, read, update, and delete operations.
├── database.py         # Script to initialize the database schema.
├── scheduler.py        # Logic for sending daily review notifications.
├── GEMINI.md           # This documentation file.
├── requirements.txt    # Python dependencies.
└── templates/          # Directory for all Jinja2 HTML templates.
    └── ...
```

## 4. Deployment & Local Testing

-   **Production (Render Free Tier):** The application is deployed as a single web service.
    -   **Telegram Bot:** The bot runs within the FastAPI application lifecycle, using a webhook for communication with Telegram. This is managed in `main.py`. For this to work, the `ENVIRONMENT` environment variable must be set to `production`.
    -   **Scheduler:** The daily scheduler is triggered by an API endpoint (`/api/trigger-scheduler`). A free, external cron job service (e.g., cron-job.org) is required to call this endpoint on a schedule.
-   **Local Development:**
    -   The web server can be run with `uvicorn main:app --reload`.
    -   The Telegram bot can be tested independently by running `python bot.py`, which starts the bot in polling mode.

## 5. Current Status (As of 2025-09-13)

The application is now significantly more robust and feature-rich. Major performance bottlenecks have been resolved, and key new features have been added. The primary focus is now on resolving the final deployment issues on Render's free tier.

### Key Accomplishments:
- **Performance Overhaul:**
    - Implemented a `psycopg2` connection pool to dramatically reduce database connection overhead.
    - Optimized several database queries, particularly for the card review and course tree pages, to improve application speed.
    - Refactored database access logic to be more efficient and prevent redundant operations.
- **AI-Generated Card Approval Workflow:**
    - Implemented a new UI modal for reviewing cards generated by Gemini or Ollama.
    - Users can now individually edit, delete, and approve each AI-generated card before saving them to the database, ensuring higher quality content.
    - Fixed a bug to ensure LaTeX renders correctly during the editing process.
- **Runnable Local Bot:** Modified `bot.py` to be a standalone, runnable script for easy local testing.
- **Secure, Multi-User Core:** The application is built on a secure, token-based (JWT) authentication system, with isolated data for each user.

### Known Issues & Resolution Path:
- **Production Bot Inactive:** The bot is not responding on Render. **Resolution:** The root cause was identified as a race condition due to multiple Gunicorn workers. The user needs to update their **Start Command** on the Render dashboard to use a single worker: `gunicorn -w 1 -k uvicorn.workers.UvicornWorker main:app`. This will ensure the bot's webhook initializes correctly.
- **Production Scheduler:** The scheduler is not running automatically. **Resolution:** This is not a bug, but a required configuration step. The user must set up a free, external cron job service (like cron-job.org) to send a daily GET request to the `https://<your-app-url>/api/trigger-scheduler?secret=<your-secret>` endpoint.

## 6. Next Steps & Future Vision

With the backend and core features now stable and performant, the next major step is a full modernization of the user interface.

### Immediate Priorities for the Next Session:
1.  **Confirm Production Fixes:** The user needs to apply the single-worker fix for the bot and set up the external cron job for the scheduler.
2.  **Plan UI Refactor:** Begin the process of decoupling the frontend and backend. This involves auditing all FastAPI routes to ensure they are ready to serve a standalone Next.js application.
3.  **Generate README:** Create a comprehensive and professional `README.md` file for the GitHub repository.

### Long-Term Vision:
- **Modern Frontend with Next.js:** Plan and execute a complete rewrite of the frontend using Next.js and TypeScript, leveraging a component-based architecture for a modern, fast, and maintainable UI.
- **Code Quality & Security Audit:** Review and refactor the codebase to improve security, readability, and maintainability.