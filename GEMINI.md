# Gemini Agent Session Documentation

This document provides a comprehensive overview of the Anki Clone project, its structure, and the development session history. It is intended to be a reference for future Gemini agents and developers.

## 1. Project Overview

This project is a web-based, simplified clone of the Anki flashcard application. It uses a spaced repetition system (inspired by SM-2) to help users study and remember information efficiently. The application is built with Python using the FastAPI framework for the backend and Jinja2 templates for the frontend. It also includes a Telegram bot for user interaction.

## 2. Core Technologies

- **Backend:** Python 3.10+ with FastAPI
- **Frontend:** Jinja2 Templates with Bootstrap 5 CSS
- **Database:** PostgreSQL (production), SQLite (local)
- **Telegram Bot:** `python-telegram-bot` library
- **Markdown Parsing:** `frontmatter` library for course content.
- **LLM Integration:** `google-generativeai` for card generation, `ollama` for local card generation.
- **Deployment:** Render.com (Free Tier)

## 3. Project Structure

The project is organized into a main FastAPI application (`main.py`), a Telegram bot (`bot.py`), database scripts, and Jinja2 templates. Course content, previously stored in local Markdown files, is now managed in a PostgreSQL database to support a stateless deployment environment.

```
/
├── main.py             # The main FastAPI application file.
├── bot.py              # Contains the logic for the Telegram bot.
├── crud.py             # Contains database create, read, update, and delete operations.
├── database.py         # Script to initialize the database schema.
├── scheduler.py        # Logic for sending daily review notifications.
├── GEMINI.md           # This documentation file.
├── requirements.txt    # Python dependencies.
└── templates/          # Directory for all Jinja2 HTML templates.
    └── ...
```

## 4. Deployment & Local Testing

-   **Production (Render Free Tier):** The application is deployed as a single web service.
    -   **Telegram Bot:** The bot runs within the FastAPI application lifecycle, using a webhook for communication with Telegram. This is managed in `main.py`. For this to work, the `ENVIRONMENT` environment variable must be set to `production`.
    -   **Scheduler:** The daily scheduler is triggered by an API endpoint (`/api/trigger-scheduler`). A free, external cron job service (e.g., cron-job.org) is required to call this endpoint on a schedule.
-   **Local Development:**
    -   The web server can be run with `uvicorn main:app --reload`.
    -   The Telegram bot can be tested independently by running `python bot.py`, which starts the bot in polling mode.

## 5. Current Status (As of 2025-09-11)

The application's code is largely complete. Local testing is now fully functional, and the primary focus is on resolving the final deployment issues on Render's free tier.

### Key Accomplishments:
- **Runnable Local Bot:** Modified `bot.py` to be a standalone, runnable script. This allows for easy local testing and development of all bot functionality using polling, completely independent of the web server.
- **Ollama Integration:** Successfully configured and tested `ollama` for local card generation.
- **Multi-User Scheduler:** The `scheduler.py` script is ready and sends notifications to all users with due cards. It's exposed via a secure API endpoint.
- **Telegram Bot Features:** The bot includes `/start`, `/register`, and `/random` commands.
- **Secure, Multi-User Core:** The application is built on a secure, token-based (JWT) authentication system, with isolated data for each user.

### Known Issues & Resolution Path:
- **Production Bot Inactive:** The bot is not responding on Render. **Resolution:** This is likely due to a silent error during the webhook setup. Enhanced logging has been added to `main.py` to diagnose this. The user needs to deploy the latest version and check the Render logs for errors during startup and when a command is sent to the bot.
- **Production Scheduler:** The scheduler is not running automatically. **Resolution:** The user must configure an external cron job service to send a GET request to the `https://<your-app-url>/api/trigger-scheduler?secret=<your-secret>` endpoint.

## 6. Next Steps & Future Vision

The immediate priority is to use the new logging to fix the production environment and then move on to new features.

### Immediate Priorities for the Next Session:
1.  **Diagnose Production Bot:** Deploy the version of `main.py` with enhanced logging and inspect the Render logs to find the root cause of the webhook failure.
2.  **Set Up External Cron Job:** The user needs to configure an external service to trigger the scheduler endpoint.
3.  **AI-Generated Card Approval Workflow:** Implement a system where users can review, approve, edit, or discard cards generated by the API or local Ollama before they are added to a course.
4.  **Generate README:** Create a comprehensive and professional `README.md` file for the GitHub repository.

### Long-Term Vision:
- **Modern Frontend with Next.js:** Plan and execute a complete rewrite of the frontend using Next.js and TypeScript.
- **Code Quality & Security Audit:** Review and refactor the codebase to improve security, readability, and maintainability.
- **Performance Optimization:** Analyze and address performance bottlenecks.
